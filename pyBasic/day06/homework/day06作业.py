# 1.
#
# ```
# n = 1
# for i in range(5):
#     print("*"*n)
#     n += 2
# ```
#
# 2.
#
# ```
# s = "**********"
# l = len(s)
# while l:
#     print("*"*l)
#     l -= 1
# ```
#
# 3.
# ```
# 3,写代码实现
#
# v1 = {"alex","wusir","taibai"}
# v2 = []
# 循环让用户输入,如果用户输入的内容在v1中存在,就添加到v2中,
# 如果v1中不存在就添加的v1中,用户输入Q退出程序
# v1 = {"alex","wusir","taibai"}
# v2 = []
# flag = input("请输入：")
# while flag.upper() != "Q":
#     if flag in v1:
#         v2.append(flag)
#     else:
#         v1.add(flag)
#     flag = input("请输入：")
#
# print(v1, v2)

# ```
#
# 4.
#
# ```
# 判断以下值那个能做字典的key ？那个能做集合的元素？
#
# 1.-1    字典的key  集合的元素
# 2.""    字典的key  集合的元素
# 3.None  字典的key  集合的元素
# 4.[1,2] 集合元素
# 5.[]    集合元素
# 6.(1,2,3)   字典的key  集合的元素
# 7.("1") 字典的key  集合的元素
# 8.(1,)  字典的key  集合的元素
# 9.{1,2,3,4}  都不可以
# 10.{"name":"alex","name1":"wusir"} 都不可以
# ```
#
# 5.
#
# ```
# is 和 == 的区别是什么?  is 比较内存地址， == 比较值
# is 是判断两个变量是不是同一个内存地址
# == 是判断两个变量值是否相等
# ```
#
# 6.
#
# ```
# id的作用是什么?
# # 返回元素所在的相当于内存地址的值
# ```
#
# 7.
#
# ```
# # 看代码写结果并解释原因(以下看代码写结果,一定要自己先思考.在验证!)
# #
# v1 = {'k1':'v1','k2':[1,2,3]}
# v2 = {'k1':'v1','k2':[1,2,3]}
# result1 = v1 == v2  # true
# result2 = v1 is v2 # False
#
# print(result1)    #True 两变量值相等
# print(result2)    #False 俩变量在相当于深拷贝字典地址不同但是元素值内存地址相同
# ```
# 8.
#
# ```
# # 看代码写结果并解释原因
#
# v1 = {'k1':'v1','k2':[1,2,3]}
# v2 = v1
# v1['k1'] = 'wupeiqi'
# print(v2["k1"] + v1["k1"])  #   'wupeiqiwupeiqi'
#                             # v2赋值给v1,v2v1指向同一个字典元素的内存地址,故v1改v2也改
# ```
#
# 9.
#
# ```
# # 看代码写结果并解释原因
# v1 = '人生苦短，我用Python'
# v2 = [1,2,3,4,v1]
# v1 = "人生苦短，用毛线Python"
# print(v2)   #   [1,2,3,4,"人生苦短，我用Python"]
#   前两条语句执行完后相当于将v1值增加给v2,后面v1只变化后,v2的元素指向不变
# ```
#
# 10.
#
# ```
# # 看代码写结果,并解释原因
# info = [1,2,3]
# userinfo = [info,info,info,info,info]
# info[0] = '不仅多，还特么难呢'
# print(info,userinfo)    #
# ['不仅多，还特么难呢',2,3]
# ['不仅多，还特么难呢','不仅多，还特么难呢','不仅多，还特么难呢','不仅多，还特么难呢','不仅多，还特么难呢']
# 因为info[0]指向的地址变了但是info指向的地址不变
# ```
#
# 11.
#
# ```
# # 看代码写结果,并解释原因
#
# dic1 = {"k1":5,"k2":10}
# dic2 = dic1.copy()
# dic2["k1"] = 1
# print(dic1["k1"] + dic2["k1"]) #   6   浅拷贝后两个字典的k1指向不同的内存地址
# ```
#
# 12.
#
# ```
# 念数字给出一个字典. 在字典中标识出每个数字的发音.
# 包括相关符号. 然后由用户输入一个数字. 让程序读出相对应的发音(单纯的打印即可,不考虑个十百)
##
# 例如: 7.5 输出: qi_dian_wu
#
# dic = {
# '0':'ling',
# '1':'yi',
# '2':'er',
# '3':'san',
# '4':'si',
# '5':'wu',
# '6':'liu',
# '7':'qi',
# '8':'ba',
# '9':'jiu',
# '.':'dian',
# }
# num = input("请输入数字：")
# str = ""
# while num:
#     num = num.strip().replace(" ", "")
#     if "." in num:
#         li = num.split(".")
#         if len(li[1]) <= 1:
#             str = dic[li[0].strip()] + " " + dic["."] + " " +dic[li[1]]
#         else:
#             str = dic[li[0].strip()] + " " + dic["."] + " "
#             for j in li[1]:
#                 str += dic[j] + " "
#     else:
#         str = dic[num]
#     print(str)
#     num = input("请输入数字：")
# ```
#
# 13.
#
# ```
# # 敲七游戏.从1开始数数.遇到7或者7的倍数要在桌上敲⼀下.编程来完成敲七.
# # 给出⼀个任意的数字n. 从1开始数. 数到n结束.把每个数字都放在列表中,
# # 在数的过程中出现7或者7的倍数(不包含类似于17,27，这种数).则向列表中添加⼀个'咣'
#
# # 例如, 输⼊10
# # lst = [1, 2, 3, 4, 5, 6, '咣', 8, 9, 10]
#

list_7 = []
num = input("任意整数：")
if num.isdecimal():
    for i in range(1, int(num)+1):
        if i % 7 == 0:
            i = "咣"
        list_7.append(i)
else:
    print("输入错误!")
print(list_7)
# ```