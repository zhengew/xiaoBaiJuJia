博客园Logo
首页
新闻
博问
专区
闪存
班级
代码改变世界
搜索
注册
登录
程序媛
Eva_J
博客园首页新随笔联系管理订阅订阅随笔- 33  文章- 173  评论- 396  阅读- 110万 
python之路——进程
阅读目录
理论知识
操作系统背景知识
什么是进程
进程调度
进程的并发与并行
同步\异步\阻塞\非阻塞
进程的创建与结束
在python程序中的进程操作
multiprocess模块
进程的创建和multiprocess.Process
进程同步控制 —— 锁 
进程间通信 —— 队列
进程间的数据共享 —— multiprocess.Manager
进程池和multiprocess.Pool
回到顶部
理论知识
操作系统背景知识
回到顶部
顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。

进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。

所以想要真正了解进程，必须事先了解操作系统，点击进入    

PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。

必备的理论基础：

复制代码
#一 操作系统的作用：
    1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口
    2：管理、调度进程，并且将多个进程对硬件的竞争变得有序

#二 多道技术：
    1.产生背景：针对单核，实现并发
    ps：
    现在的主机一般是多核，那么每个核都会利用多道技术
    有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个
    cpu中的任意一个，具体由操作系统调度算法决定。
    
    2.空间上的复用：如内存中同时有多道程序
    3.时间上的复用：复用一个cpu的时间片
       强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样
            才能保证下次切换回来时，能基于上次切走的位置继续运行
复制代码
回到顶部
什么是进程
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。
广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。
第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。[3] 
进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。
 操作系统引入进程的概念的原因
 进程的特征
 进程与程序中的区别
注意：同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。

回到顶部
进程调度
要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随即进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。

 先来先服务调度算法
 短作业优先调度算法
 时间片轮转法
 多级反馈队列
回到顶部
进程的并行与并发
并行 : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）

并发 : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。

区别:

并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。
并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。

回到顶部
同步异步阻塞非阻塞
状态介绍


　　在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。

　　（1）就绪(Ready)状态

　　当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。

　　（2）执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。

　　（3）阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。

      

同步和异步
      所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。

　　所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。

 例子
阻塞与非阻塞
      阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的

 例子
同步/异步与阻塞/非阻塞
同步阻塞形式
　　效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。

异步阻塞形式
　　如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；

　　异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。

同步非阻塞形式
　　实际上是效率低下的。

　　想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。

异步非阻塞形式
　　效率更高，

　　因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。

　　比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。

　　

很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。

回到顶部
进程的创建与结束
进程的创建
　　但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。

　　而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程：

　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）

　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）

　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）

　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）

　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。　　

 创建进程
进程的结束
　　1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）

　　2. 出错退出（自愿，python a.py中a.py不存在）

　　3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）

　　4. 被其他进程杀死（非自愿，如kill -9）

回到顶部
在python程序中的进程操作
　　之前我们已经了解了很多进程相关的理论知识，了解进程是什么应该不再困难了，刚刚我们已经了解了，运行中的程序就是一个进程。所有的进程都是通过它的父进程来创建的。因此，运行起来的python程序也是一个进程，那么我们也可以在程序中再创建进程。多个进程可以实现并发效果，也就是说，当我们的程序中存在多个进程的时候，在某些时候，就会让程序的执行速度变快。以我们之前所学的知识，并不能实现创建进程这个功能，所以我们就需要借助python中强大的模块。

回到顶部
multiprocess模块
      仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。

回到顶部
multiprocess.process模块
process模块介绍
process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。

复制代码
Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）

强调：
1. 需要使用关键字的方式来指定参数
2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号

参数介绍：
1 group参数未使用，值始终为None
2 target表示调用对象，即子进程要执行的任务
3 args表示调用对象的位置参数元组，args=(1,2,'egon',)
4 kwargs表示调用对象的字典,kwargs={'name':'egon','age':18}
5 name为子进程的名称
复制代码

1 p.start()：启动进程，并调用该子进程中的p.run() 
2 p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  
3 p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁
4 p.is_alive():如果p仍然运行，返回True
5 p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  
 属性介绍
 在windows中使用process模块的注意事项
 

使用process模块创建进程
在一个python进程中开启子进程，start方法和并发效果。


复制代码
import time
from multiprocessing import Process

def f(name):
    print('hello', name)
    print('我是子进程')

if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p.start()
    time.sleep(1)
    print('执行主进程的内容了')
    
复制代码
 join方法
 查看主进程和子进程的进程号
 

进阶，多个进程同时运行（注意，子进程的执行顺序不是根据启动顺序决定的）

 多个进程同时运行
 多个进程同时运行，再谈join方法(1)
 多个进程同时运行，再谈join方法(2)
 

除了上面这些开启进程的方法，还有一种以继承Process类的形式开启进程的方式

 通过继承Process类开启进程
 

进程之间的数据隔离问题

 进程之间的数据隔离问题
守护进程
会随着主进程的结束而结束。

主进程创建守护进程

　　其一：守护进程会在主进程代码执行结束后就终止

　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children

注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止

 守护进程的启动
 主进程代码执行结束守护进程立即结束
socket聊天并发实例
 使用多进程实现socket聊天并发-server
 client端
多进程中的其他方法
 进程对象的其他方法:terminate,is_alive
 进程对象的其他属性:pid和name
回到顶部
进程同步(multiprocess.Lock)
锁 —— multiprocess.Lock
      通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，他们之间的运行没有顺序，一旦开启也不受我们控制。尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题。

　　当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。

 多进程抢占输出资源
 使用锁维护执行顺序
　　上面这种情况虽然使用加锁的形式实现了顺序的执行，但是程序又重新变成串行了，这样确实会浪费了时间，却保证了数据的安全。

　　接下来，我们以模拟抢票为例，来看看数据安全的重要性。 

 多进程同时抢购余票
 使用锁来保证数据安全
 

复制代码
#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。
虽然可以用文件共享数据实现进程间通信，但问题是：
1.效率低（共享数据基于文件，而文件是硬盘上的数据）
2.需要自己加锁处理

#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。
队列和管道都是将数据存放于内存中
队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，
我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。 
复制代码
回到顶部
进程间通信——队列（multiprocess.Queue）
进程间通信
IPC(Inter-Process Communication)

队列 
概念介绍
创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。 

Queue([maxsize]) 
创建共享的进程队列。
参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。
底层队列使用管道和锁定实现。
 方法介绍
 其他方法(了解)
代码实例
 单看队列用法
上面这个例子还没有加入进程通信，只是先来看看队列为我们提供的方法，以及这些方法的使用和现象。

 子进程发送数据给父进程
上面是一个queue的简单应用，使用队列q对象调用get函数来取得队列中最先进入的数据。 接下来看一个稍微复杂一些的例子：

 批量生产数据放入队列再批量获取结果 x
生产者消费者模型
在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。

为什么要使用生产者和消费者模式
在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。

什么是生产者消费者模式
生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

基于队列实现生产者消费者模型
 基于队列实现生产者消费者模型
此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。

解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环。

 改良版——生产者消费者模型
注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号

 主进程在生产者生产完毕后发送结束信号None
但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决

 多个消费者的例子：有几个消费者就需要发送几次结束信号
 

JoinableQueue([maxsize]) 
创建可连接的共享进程队列。这就像是一个Queue对象，但队列允许项目的使用者通知生产者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。 

 方法介绍
 JoinableQueue队列实现消费之生产者模型
回到顶部
进程之间的数据共享
展望未来，基于消息传递的并发编程是大势所趋

即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。

这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。

但进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题。

以后我们会尝试使用数据库来解决现在进程之间的数据共享问题。

 Manager模块介绍
 Manager例子
 

 

回到顶部
进程池和multiprocess.Pool模块
进程池
为什么要有进程池?进程池的概念。

在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？

在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。

multiprocess.Pool模块
概念介绍
Pool([numprocess  [,initializer [, initargs]]]):创建进程池
 参数介绍
 主要方法
 其他方法(了解)
代码实例
进程池和多进程效率对比
p.map进程池和进程效率测试
同步和异步
 进程池的同步调用
 进程池的异步调用
练习
 server：进程池版socket并发聊天
 client
发现：并发开启多个客户端，服务端同一时间只有4个不同的pid，只能结束一个客户端，另外一个客户端才会进来.

回调函数
需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数

我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I/O的过程，直接拿到的是任务的结果。
 

 使用多进程请求多个url来减少网络等待浪费的时间
 

 爬虫实例
 

如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数

 无需回调函数
进程池的其他实现方式：https://docs.python.org/dev/library/concurrent.futures.html

参考资料
http://www.cnblogs.com/linhaifeng/articles/6817679.html
https://www.jianshu.com/p/1200fd49b583
https://www.jianshu.com/p/aed6067eeac9


好文要顶 关注我 收藏该文  
Eva_J
关注 - 7
粉丝 - 4778
+加关注
71
posted @ 2018-01-19 08:32  Eva_J  阅读(20837)  评论(15)  编辑  收藏  举报
刷新评论刷新页面返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】百度智能云开发者赋能计划，云服务器4元起，域名1元起
【推荐】华为开发者专区，与开发者一起构建万物互联的智能世界

编辑推荐：
· asp.net core启动源码以及监听，到处理请求响应的过程
· ASP.NET Core 高性能服务器 HTTP.SYS
· 中小团队的技术负责人如何做好技术团队建设
· 巧用 background-clip 实现超强的文字动效
· .NET如何快速比较两个byte数组是否相等
最新新闻：
· 起底“东数西算”概念股依米康：28次股权交易下的“大数据”秘事
· 牛津大学最新调研：AI面临基准危机，NLP集中“攻关”推理测试
· 电商行业的倒春寒
· 我离开谷歌，决定创业后的几点感悟
· 我新入职的“同事”们，既能干脏活累活，又不内卷，真香！
» 更多新闻...
昵称： Eva_J
园龄： 6年5个月
粉丝： 4778
关注： 7
+加关注
<	2022年4月	>
日	一	二	三	四	五	六
27	28	29	30	31	1	2
3	4	5	6	7	8	9
10	11	12	13	14	15	16
17	18	19	20	21	22	23
24	25	26	27	28	29	30
1	2	3	4	5	6	7
搜索
 
 
常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
更多链接
我的标签
go(1)
python(1)
随笔分类
python_Django(4)
python基础语法(7)
python面向对象(4)
python网络编程(1)
python线程进程与协程(6)
随笔档案
2020年3月(1)
2019年3月(1)
2018年7月(1)
2018年1月(1)
2017年8月(1)
2017年4月(1)
2016年6月(2)
2016年4月(1)
2016年3月(1)
2016年2月(1)
2016年1月(10)
2015年12月(6)
2015年11月(6)
文章分类
flask(1)
go(3)
mysql(7)
python宣讲专用课件(3)
python之路(16)
数据库相关(7)
周末班(3)
友链
银角大王
学霸yuan先生
冷先生
阅读排行榜
1. python之路——博客目录(179132)
2. python——赋值与深浅拷贝(37436)
3. python——SQL基本使用(36989)
4. python——django使用mysql数据库（一）(26856)
5. 前端开发的正确姿势——各种文件的目录结构规划及引用(24982)
评论排行榜
1. python之路——博客目录(38)
2. python——赋值与深浅拷贝(16)
3. python——进程基础(9)
4. python_控制台输出带颜色的文字方法(8)
5. python的类和对象——进阶篇(8)
推荐排行榜
1. python之路——博客目录(74)
2. python——赋值与深浅拷贝(37)
3. python3.7导入gevent模块报错的解决方案(6)
4. python_控制台输出带颜色的文字方法(6)
5. DOM加载顺序(6)
最新评论
1. Re:mysql表的完整性约束
老师，你真的好厉害

--苦行僧冬*婷
2. Re:mysql性能分析之explain
说真的 不详细 有些话还不通顺

--妍妍叫我肉肉
3. Re:python之路——初识面向对象
@yushujun0629 你说巧不巧？...
--Eva_J
4. Re:python之路——进程
回调函数是什么？不太明白

--强仔必胜
5. Re:python的类和对象——类的静态字段番外篇
代码中的：father_obj1.money['money'] = father_obj1.money['money'] + 1 应该是继承搜索并修改，不能算是对实例对象创建一个字典吧，python中...
--影子月
Copyright © 2022 Eva_J
Powered by .NET 6 on Kubernetes